<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mouse-Controlled Image Rotation</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: #000;
        min-height: 100vh;
        height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0;
        margin: 0;
        overflow: hidden;
      }

      .container {
        background: #000;
        width: 100vw;
        height: 100vh;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
      }

      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
        font-size: 2.5rem;
        background: linear-gradient(45deg, #667eea, #764ba2);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .viewer-container {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100vw;
        height: 100vh;
        background: #000;
        overflow: hidden;
        cursor: grab;
        user-select: none;
      }

      .viewer-container:active {
        cursor: grabbing;
      }

      .image-viewer {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .rotating-image {
        width: 100%;
        height: 100%;
        object-fit: contain;
        transition: opacity 0.3s ease;
      }

      .placeholder {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-size: 1.2rem;
        gap: 15px;
        text-align: center;
      }

      .placeholder-icon {
        font-size: 3rem;
        opacity: 0.5;
      }

      .loading {
        opacity: 0.5;
        pointer-events: none;
      }

      .frame-counter {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 0.8rem;
        font-weight: bold;
      }

      @media (max-width: 768px) {
        body {
          overflow: hidden;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="viewer-container" id="viewerContainer">
        <div class="placeholder">
          <div class="placeholder-icon">üñºÔ∏è</div>
          <div>Loading animation sequence...</div>
          <small>Move your mouse left/right to rotate through frames</small>
        </div>
      </div>
    </div>

    <script>
      let images = [];
      let currentImageIndex = 0;
      let mouseX = 0;
      let lastMouseX = 0;
      let sensitivity = 1;
      let smoothing = 5;
      let isMouseInViewer = false;
      let frameBuffer = [];

      const viewerContainer = document.getElementById("viewerContainer");

      // Mouse tracking
      viewerContainer.addEventListener("mouseenter", () => {
        isMouseInViewer = true;
      });

      viewerContainer.addEventListener("mouseleave", () => {
        isMouseInViewer = false;
      });

      viewerContainer.addEventListener("mousemove", (e) => {
        if (!isMouseInViewer || images.length === 0) return;

        const rect = viewerContainer.getBoundingClientRect();
        const relativeX = (e.clientX - rect.left) / rect.width;

        // Calculate target frame based on mouse position
        const targetFrame = Math.floor(relativeX * images.length);
        const clampedFrame = Math.max(
          0,
          Math.min(images.length - 1, targetFrame)
        );

        // Apply smoothing
        frameBuffer.push(clampedFrame);
        if (frameBuffer.length > smoothing) {
          frameBuffer.shift();
        }

        // Calculate average frame
        const avgFrame = Math.round(
          frameBuffer.reduce((a, b) => a + b, 0) / frameBuffer.length
        );

        if (avgFrame !== currentImageIndex) {
          currentImageIndex = avgFrame;
          updateDisplay();
        }
      });

      function updateViewer() {
        if (images.length === 0) return;

        viewerContainer.innerHTML = "";

        const imageViewer = document.createElement("div");
        imageViewer.className = "image-viewer";

        const img = document.createElement("img");
        img.src = images[currentImageIndex].src;
        img.className = "rotating-image";
        img.alt = `Frame ${currentImageIndex + 1}`;

        const frameCounter = document.createElement("div");
        frameCounter.className = "frame-counter";
        frameCounter.textContent = `${currentImageIndex + 1}/${images.length}`;

        imageViewer.appendChild(img);
        imageViewer.appendChild(frameCounter);
        viewerContainer.appendChild(imageViewer);
      }

      function updateDisplay() {
        if (images.length === 0) return;

        const img = viewerContainer.querySelector(".rotating-image");
        const counter = viewerContainer.querySelector(".frame-counter");

        if (img && images[currentImageIndex]) {
          img.src = images[currentImageIndex].src;
          img.alt = `Frame ${currentImageIndex + 1}`;
        }

        if (counter) {
          counter.textContent = `${currentImageIndex + 1}/${images.length}`;
        }
      }

      // Auto-load images from folder on page load
      function autoLoadImages() {
        const basePath =
          // "assets/animation/2025-11-01-bg-cosmo-pink-mini/";
          "https://assets.codepen.io/948509/";

        const imagePromises = [];

        // Generate image paths from _2025-11-01_06 to _2025-11-01_32
        for (let i = 1; i <= 32; i++) {
          const paddedNumber = String(i).padStart(3, "0");
          const imagePath = `${basePath}_2025-11-01_${paddedNumber}-small.jpeg`;

          const promise = new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => {
              console.warn(`Failed to load: ${imagePath}`);
              resolve(null);
            };
            img.src = imagePath;
          });

          imagePromises.push(promise);
        }

        viewerContainer.classList.add("loading");

        Promise.all(imagePromises).then((loadedImages) => {
          // Filter out any failed images
          images = loadedImages.filter((img) => img !== null);

          if (images.length > 0) {
            currentImageIndex = 0;
            frameBuffer = [];
            updateViewer();
            viewerContainer.classList.remove("loading");
          } else {
            viewerContainer.classList.remove("loading");
            console.error(
              "No images could be loaded from the specified folder"
            );
          }
        });
      }

      // Initialize and auto-load images
      autoLoadImages();
    </script>
  </body>
</html>
